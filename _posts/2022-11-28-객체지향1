---
title:  "객체 지향 中 : 모듈화"

categories:
  - 프로그래밍/개념공부
tags:
  - [프로그래밍 개념, 객체 지향]

toc: true
toc_sticky: true
 
date: 2022-11-28
last_modified_at: 2022-11-28
---

<h1>주의! 아직 작성중인 글입니다.</h1>

---

<h1>모듈화(化)</h1>
우리는 지식을 배우며 생각보다 많은 원리들을 인간이 규명해두었음을 알게 된다. 나의 경우에는 언어(Language)를 공부하면서 이러한 깨달음을 얻었는데, 예를 들어 우리가 아는 영어는 실은 언어유형학적으로 중국어와 같은 고립어(Isolated Language)로 분류되며 비교언어학적으로는 인도-유럽어족(또는 인구어, 印歐語)의 게르만어족에 속하는 언어이다. 이러한 차이는 영어를 안다면 중국어를, 혹은 독일어, 스웨덴어, 덴마크어 등을 쉽게 배울 수 있을 것이라 추론하게 되는 배경이 된다. 이들 언어는 언어유형학과 비교언어학이라는 두 관점에서 영어와 많은 특성이 비슷한 언어이기 때문이다.  
이러한 특징을 알게 되면 영어라는 언어를 그 구조와 기원을 따져가며 보다 다각도로, 그리고 좀 더 세부적으로 이해할 수 있게 된다. 그러나 이러한 지식이 없더라도 영어를 배우고 말하는 데에는 문제가 없다.  
컴퓨터라는 분야로 주제를 옮겨도 이러한 흐름은 마찬가지이다. 컴퓨터의 기원이 2차 세계대전이 한창이던 시기 영국의 독일 암호 해석 업무를 맡던 앨런 튜링이 대(對)에니그마 최종병기를 만든 것이 컴퓨터 역사의 시작이다. 폰 노이만이 현대 컴퓨터 구조를 정립한 것은 이후의 일이다.  
이러한 배경을 아는 순간 컴퓨터가 향해왔던 목표 지향점이 설명되면서 CPU 아키텍처는 이유있는 구조가 된다. 그런데 이러한 배경을 전혀 모르더라도 우리가 컴퓨터를 배우고 사용하는 데에는 문제가 없다.

> "원숭이는 비행기를 타더라도 비행기의 작동원리를 이해할 가능성은 없고 앞으로도 없을 것이다."
이것은 기술적 특이점을 소개할 때 자주 나오는 인용구이다. 보통은 뒤이어 "보통의 경우 인간은 원숭이와 다르게 지식을 배워나감으로서 비행기를 이해할 수 있다. 그런데, 인공지능과 같은 기계의 산물이 인간의 이해범주를 뛰어넘게 되면 우리는 하나의 원숭이가 되는 셈이지 않은가"라고 기술적 특이점에 대한 설명을 이어나가지만, 여기서는 다른 의미를 찾아보겠다.  
지식을 배워나가 비행기를 이해할 수 있다는 설명을 뒤집자면 지식을 배우기 전의 우리는 한 마리의 원숭이와 같다. 우리는 비행기에 대한 작동원리와 설계방법을 이해하고 암기할 수 있지만 조종사나 항공기 정비사와 같은 특정한 직업을 목표로 하고 있는 것이 아니라면 일반적으로 비행기에 대한 지식은 배우지 않고 관심도 두지 않는다. 나 같은 경우엔, 대신 외국어나 프로그래밍에 관심을 갖는다.  
그런데 마찬가지로 비행기를 이용하는 데에는 아무런 불편함이 없다. 베르누이 방정식부터 시작해 오토파일럿(AP)의 작동원리, 플랩(FLAP)이나 리버싱(Reversing) 등의 항공기 조작을 위한 용어는 승객이 모르고 있더라도 기장과 부기장만이 제대로 이해하고 있다면 항공기 운항에는 큰 문제가 없다.  
이게 어떻게 가능할까?

이것은 분업과 관련이 있다.  
분업의 목표는 특정 역할을 수행하는 인력을 양성함과 조직을 구성함에 있다. 대장장이가 금속을 녹여 냉병기와 농기구를 주조하면 칼과 창을 받은 군인은 적절한 훈련을 거친 뒤 전쟁에 투입되어왔고, 괭이와 쟁기를 받은 농부는 밭을 갈구고 식량을 생산해 왔다.  
분업이 가져오는 영향 중 하나는 지식의 패키징화이다. 분업은 특정 분야 종사자들을 병렬로 연결하는 커뮤니티를 형성하고, 지식은 이 네트워크를 타고 흐르며 매 순간마다 수정되고 발전하며 어떤 때에는 적절하게 사용된다.  
이 과정은 개인을 포함한 한 커뮤니티가 특정한 기능을 수행하도록 유도한다. 모듈(Module)이다.  

따라서 비유하자면, 특정 분야로 진입한다는 것은 베일에 싸여 왔던 지식의 포장을 뜯고 내용물을 확인하는 것과 같다.

---

프로그래밍을 예시로 들어 보겠다.  
더하기 기능이 구현된 간단한 계산기 프로그램을 만드는 상황을 가정해보자.  
Python으로는 몇 줄이면 코드 작성이 끝난다.  

```
a = input()
b = input()

print(a + b)
```

고등학교, 대학교에서 컴퓨터 프로그래밍에 대한 경험을 계속 쌓아왔다면 이 코드가 엄청 지루하게 느껴질지도 모른다.  
그러나 내가 기억하기로, 프로그래밍을 처음 배워나가면서 계산기를 처음 구현해본 것 만큼 신기하고 경이로운 경험은 없었던 것 같다. 그 때는 내가 남들과 달리 계산기의 원리를 이해하고 있다며 특별한 경험을 하고 있다는 생각까지 들었던 것으로 기억한다.  
그러나 실제로 계산기 프로그램의 동작원리를 이해하기 위해서는 진수변환, 논리연산(NOT, AND, OR, XOR...)의 개념과 쓰임새를 이해하야 한다. 예를 들어, "3 + 4 = 7"는 간단해 보이지만 실제로는 컴퓨터에서는 "011 + 100 = 111"의 과정이 지나간다. 연산 대상이 되는 수의 규모가 커진다거나 수의 범위가 실수까지 확장된다거나, 혹은 곱셈과 나눗셈, 루트와 지수와 로그, 삼각함수 등의 고등연산으로 나아간다거나 할수록 컴퓨터의 계산은 더 복잡해진다.  

내가 이러한 과정에 실제로 도달하기까지에는 크게 두 단계가 걸렸다.  
무지식 -> Python 프로그래밍 -> 컴퓨터지식.

...이어서 쓰렴

<h1></h1>

---
<h1>참고</h1>



---


<h2><b>객체지향 프로그래밍(OOP)</b></h2>
객체지향 프로그래밍이 무엇인지 검색해봐도 비유법 없이 개념을 세세하게 설명하는 글을 찾기가 힘들었다.  
보조관념에 형성되어 있는 문화적 속성을 원관념에 적용할 수 있다는 것은 비유법의 분명한 장점이지만, 보조관념과 원관념이 결국에는 서로 다른 개념이라는 한계가 있다. 그래서 개념을 정확히 살펴잡으려 할 때 혼동이 있었다.  

비유법 없이 작성된 글도 표현이 추상적이다라는 인상이 드는 글이 많았다. 아마 내가 입문자였기 때문에 좀 더한 친절을 기대했기 때문일 수도 있다.  
다만 어쨌든 입문자의 눈에 보이기에 많은 글들은 어느 순간 설명이 툭 끊겨있는 느낌이었고, 그러한 글들을 피해 작성이 완전한 것으로 보이는 글을 찾아보아도 찾기가 어려워서 직접 정리해 보았다.

---

<h3>큰 규모의 단일 코드에서 아름다움 대신 복잡함이 느껴지기 시작할 때</h3>
객체지향의 개념이 나타났다. 그래서 객체지향의 가장 강한 목표는 "필요한 함수와 데이터를 한군데에 묶어 외부의 코드가 접근할 수 없게 만드는 것"이다. 이것은 코드간 의존성을 영점에 가깝게 줄이고 각 코드가 독립적으로 기능할 수 있게 만드는 효과를 가져온다. 각 코드가 독립적으로 기능하기 때문에 문제가 되는 코드를 따로 도려내어도 문제가 되지 않고, 필요하다면 코드를 치료한 뒤 제자리에 부착할 수도 있다. 잘 구현된 객체지향 코드에서는 이런 의도된 이점을 얻을 수 있다.

단점은 연산량이 늘어나 메모리 요구량과 코드 실행 시간이 늘어난다는 것이다. 이것은 절차지향 코드에 비교했을 때 그렇다는 것이며 ~???


[내가 오해했던 것]
객체지향이라는 이름은 유형에 관한 것이 아니라 개념에 관한 것이다. 이것은 "객체지향 언어"라는 표현에서 비롯되기 쉬운 오해인데, 객체지향 언어라고 해서 객체지향 프로그래밍이 강제되는 것은 아니다.

---

<h4>클래스(Class)</h4>
객체를 생성하기 위해 변수와 메소드를 정의하는 공간이다. 일종의 견본(Template)이다.
클래스를 만든다는 것은 

<h4>네임스페이스(NameSpace)</h4>


<h4>필드(Field)와 메서드(Method)</h4>
> a member variable (sometimes called a member field) is a variable that is associated with a specific object, and accessible for all its methods (member functions). - 영문 위키백과(2022.08.24)

필드와 메서드는 클래스에 작성되는 변수와 함수를 말하는데, 일반적인 프로그래밍(= 절차지향 프로그래밍, PP)에서 보이던 개념과는 또 다른 중요한 개념이기 때문에 별도의 이름을 갖고 있다.
각각 클래스에서 속성(Property)과 기능(function)의 역할을 맡고 있다.  

필드와 메서드를 함쳐 멤버(Member)라고 부른다.

<h4>객체(Object)와 인스턴스(Instance)</h4>

객체와 인스턴스 클래스에 정의된 것을 토대로 메모리에 할당된 것을 말한다.

객체는 "추상화"라는 특징적 표현과는 별개로, 그 개념 자체가 일부는 추상적이라는 것을 전제로 설명하는 것이 조금 보편적인 것 같다. 추상적이라는 것은 측정할 수 있는 것도 아니고 속성도 전원 스위치처럼 0과 1로 이분되는 것이 아니기 때문에 어느 정도는 맞는 말이지만, 읽는이가 갈피를 잘 못 잡게 하는 것이 흠이다 싶다.  

객체는 new 연산자로 생성한다. Java든 C#이든 동일하다.

<h4>접근 제한자</h4>
객체지향의 핵심이라고 생각한다. 객체지향의 특성 중 캡슐화와 은닉화는 접근 제한자로 구현된다. 시스템적으로 아무나 접근할 수 없도록 막는 것이 분리된 공간을 만들고 이 떨어진 공간은 곧 독립적으로 기능하게 되는 것이다.  

<b>public</b>
모든 외부 객체에 대해 접근을 허용한다.  

<b>private</b>
외부의 접근을 차단한다. 파생클래스에서도 접근할 수 없다.  

<b>protected</b>
상속 클래스에 대해서만 접근을 허용한다.  

<b>static</b>
같은 폴더에 있는 객체의 

++ C#에서는 다음이 추가된다.  

<b>internal</b>
.NET 어셈블리 안의 다른 클래스에서 접근할 수 있다.  
[.NET](https://dotnet.microsoft.com/en-us/)은 마이크로소프트가 개발한 프레임워크, [어셈블리](https://docs.microsoft.com/ko-kr/dotnet/standard/assembly/)는 .exe나 .dll과 같이 .NET 프로그램의 배포 단위이다.  
public, private, protected 등이 클래스의 계층구조에 따라 논리적으로 접근 권위를 결정한다면, internal은 같은 어셈블리 내에 있느냐에 따라 물리적으로 접근 권위를 결정한다. 즉 동일 어셈블리 안이라면 public, 어셈블리 외부라면 private로 작동한다.  

<b>protected internal</b>
어셈블리 내의 클래스 중 파생클래스에 한해 접근을 허용한다.

<h4>식별자</h4>

<h4>생성자와 소멸자</h4>

<h4>[C#] 인덱서(indexer)</h4>
인덱스는 배열의 요소마다 붙여진 일련번호로 각 요소를 구별하는데 사용되는 인자로, "색인"이라는 뜻이다.  
C#에서 인덱서(er)는 클래스로부터 생성된 각 객체를 배열처럼 취급해

---

<h3>객체지향의 과정</h3>
클래스를 작성한다.

<h3></h3>
객체를 만들 때 클래스에 투입되는 데이터는 정해진 상수가 아닌 배열 형의 데이터일 수도 있다.

---

<h4>유니티에서의 사용</h4>