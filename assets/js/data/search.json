[ { "title": "람다(λ) 함수", "url": "/posts/%EB%9E%8C%EB%8B%A4%ED%95%A8%EC%88%98/", "categories": "프로그래밍", "tags": "프로그래밍, 개념", "date": "2023-01-06 00:00:00 +0900", "snippet": "람다함수이름이 없는 익명 함수(Anonymous Function)로서, 코드를 간결하게 만들고 반복 관련 코드의 불필요한 부분을 제거하기 위해 사용한다.# 람다 형식(lambda 매개변수, 식)(인자값)# 예시 1sum = (lambda x,y: x + y)(1, 2)print(sum)# 예시 2greet = lambda : print('hello, world!')greet()// 람다 형식(매개변수, ... ) -&gt; { 실행문 ... }// 예시 1(x, y) -&gt; x + y;// 예시 2() -&gt; \"Hello World!\";참고" }, { "title": "[일본어] 설국 첫문장", "url": "/posts/%EC%84%A4%EA%B5%AD/", "categories": "외국어", "tags": "일본어", "date": "2023-01-02 00:00:00 +0900", "snippet": "雪国 ( ゆきぐに )国境の長いトンネルを抜けると雪国であった。夜の底が白くなった。信号所に汽車が止まった。向側の座席から娘が立ってきて、島村の前のガラス窓を落した。雪の冷気が流れこんだ。娘は窓いっぱいに乗り出して遠くへ叫ぶように、「駅長さあん、駅長さあん。」明りをさげてゆっくり雪を踏んで来た男は、襟巻で鼻の上まで包み、耳に帽子の毛皮を垂れていた。참고가와바타 야스나리(川端 康成)" }, { "title": "[러시아어] 노어 격변화", "url": "/posts/%EB%9F%AC%EC%8B%9C%EC%95%84%EC%96%B4-%EA%B2%A9%EB%B3%80%ED%99%94/", "categories": "외국어", "tags": "러시아어", "date": "2023-01-02 00:00:00 +0900", "snippet": "노어 격변화" }, { "title": "[중국어] 그 시절, 우리가 좋아했던 소녀", "url": "/posts/%EA%B7%B8-%EC%8B%9C%EC%A0%88-%EC%9A%B0%EB%A6%AC%EA%B0%80-%EC%A2%8B%EC%95%84%ED%96%88%EB%8D%98-%EC%86%8C%EB%85%80/", "categories": "외국어", "tags": "중국어", "date": "2023-01-02 00:00:00 +0900", "snippet": "那些年，我们一起追的女孩nà xiē nián，wǒmén yìqǐ zhuī de nǔ hái六年前，liùniánqián，刚刚踏进精诚中学国中部的时候，gāng gāng tà jìn jīng chéng zhōng xué guó zhōng bù de shí hou，十二岁的我们懵懵懂懂，shíèr suì de wǒmen měngměng dǒngdǒng，虽然对未来有无限的想像，suī rán duì wèi lái yǒu wú xiàn de xiǎngxiàng，却不知道能在学习到什么、收获到什么，què bù zhī dào néng zài xué xí dào shén me 、shōu huò dào shén me，幸好一路上有师长的谆谆教诲，xìng hǎo yī lù shàng yǒu shī cháng de zhūn zhūn jiào huì，同学们也建立了深厚的情谊，tóng xué mén yě jiàn lì liǎo shēn hòu de qíng yì，一起经历了困难挫折，yī qǐ jīng lì liǎo kùn nán cuò zhē，也一起携手成长。yě yī qǐ xié shǒu chéng cháng 。我说，精诚中学就是我们的青春，wǒ shuō，jīng chéng zhōng xué jiù shì wǒ mén de qīng chūn，也是最美好的行囊，yě shì zuì měi hǎo de xíng náng，毕业典礼后，bì yè diǎn lǐ hòu，让我们用力的张开翅膀，ràng wǒ mén yòng lì de zhāng kāi chì bǎng，飞向各自不同的梦想！fēi xiàng gè zì bù tóng de mèng xiǎng ！各位同学，我们珍重再见！gè wèi tóng xué ，wǒ mén zhēn zhòng zài jiàn ！참고" }, { "title": "비주얼 스튜디오 코드에서 32비트 가상환경 열기", "url": "/posts/32bit/", "categories": "32비트", "tags": "32비트", "date": "2023-01-01 00:00:00 +0900", "snippet": "주의! 아직 작성중인 글입니다.32비트 가상환경을 열어야 하는 이유왜 불편하게 32비트를 이용하는지 궁금해서 그 이유를 찾아보니, 공인인증서 모듈이 32비트로만 동작하기 때문이라는 내용을 찾을 수 있었다.가상환경 열기32비트 가상환경을 구축하기 위해 아나콘다(Anaconda)를 많이 사용하는 것 같은데, 비주얼 스튜디오 차원에서도 가상환경을 열 수 있다. 32비트 가상환경 파일 만들기가상환경 파일을 만들 주소로 이동하여 가상환경 파일을 작성한다.python -m venv 파일이름만약 위와 같이 진행했는데 32bit 가상환경이 잘 작동하지 않을 경우, 32비트 파이썬(윈도우)를 설치한 뒤 “32비트 파이썬 실행파일이 위치한 경로”를 이용하여 가상환경 파일을 만들면 도움이 될 수 있다.C:\\Users\\UserNameHere\\AppData\\Local\\Programs\\Python\\Python311-32\\python.exe -m venv venv32bit 가상환경 열기가상환경은 Scripts 파일 안의 Activate.ps1로 열 수 있다.cd Scripts.\\Activate.ps1# 예시 동작 :(venv32bit) PS C:\\ASTP\\python\\venv32bit\\Scripts&gt; 가상환경 종료가상환경은 간단한 명령어로 종료시킬 수 있다.```bashdeactivate예시 동작 :C:\\ASTP\\python\\venv32bit\\Scripts&gt;```—참고" }, { "title": "ASTP", "url": "/posts/ASTP/", "categories": "프로젝트", "tags": "프로젝트, ASTP", "date": "2022-12-28 00:00:00 +0900", "snippet": "라이브러리 설치pip install mojito2pip install finance-datareader안드로이드 개발목적 : Android Studio로 한국투자증권 API 사용한 주식 자동 트레이딩 만들기(https://www.truefriend.com/main/customer/systemdown/OpenAPI.jsp?cmd=TF04ea01200)[한국투자증권 API 및 예제]란에서 eFriend Expert(Open API)와 개발설명서, 그리고 샘플을 받았다. build.grandle 수정참고(티스토리 블로그)[https://stockant.tistory.com/343]" }, { "title": "ADB 주요 명령어", "url": "/posts/ADB/", "categories": "ADB", "tags": "안드로이드, ADB", "date": "2022-12-23 00:00:00 +0900", "snippet": "기기와의 연결 확인adb devices기기내 어플 제거 명령어adb shell pm uninstall -k --user 0 \"pkg_name\"기기내 어플 비활성화 명령어adb shell pm disable --user 0 pkg_name상단바 숨기기adb shell settings put global policy_control immersive.status=*기기와의 연결 끊기adb kill-servers" }, { "title": "에어 액션 지원 안드로이드 어플", "url": "/posts/%EC%97%90%EC%96%B4%EC%95%A1%EC%85%98/", "categories": "프로젝트", "tags": "프로젝트", "date": "2022-11-20 00:00:00 +0900", "snippet": "주의! 아직 작성중인 글입니다.AirActions_Sample과 Spen_Remote_SDK_sample이 있는데, 후자를 살펴본다.MainActivity.javapackage com.samsung.android.sample.spenremote;import android.app.Activity;import android.os.Bundle;import android.util.Log;import android.view.View;import android.widget.Button;import android.widget.TextView;import android.widget.Toast;import com.samsung.android.sdk.penremote.AirMotionEvent;import com.samsung.android.sdk.penremote.ButtonEvent;import com.samsung.android.sdk.penremote.SpenEvent;import com.samsung.android.sdk.penremote.SpenEventListener;import com.samsung.android.sdk.penremote.SpenRemote;import com.samsung.android.sdk.penremote.SpenUnit;import com.samsung.android.sdk.penremote.SpenUnitManager;public class MainActivity extends Activity { private static final String TAG = \"SpenRemoteSample\"; // TextView : 텍스트 표시 private TextView mButtonState; private TextView mAirMotion; // Button : 버튼 private Button mConnectButton; // 펜 하드웨어와의 연결 private Button mMotionButton; // 가속도 측정값의 출력 private SpenRemote mSpenRemote; private SpenUnitManager mSpenUnitManager; private boolean mIsMotionListening = false; // 첫 번째 메소드 : onCreate() // mConnectButton과 mMotionButton 두 개 버튼 대한 세부 정의를 수행한다. @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mButtonState = findViewById(R.id.button_state); mAirMotion = findViewById(R.id.air_motion); // 참조 : https://developer.samsung.com/galaxy-spen-remote/api-reference/com/samsung/android/sdk/penremote/SpenRemote.html // setConnectionStateChangeListener 메소드 : \"Set the callback that pass connection state when the state is changed.\" mSpenRemote = SpenRemote.getInstance(); mSpenRemote.setConnectionStateChangeListener(new SpenRemote.ConnectionStateChangeListener() { // setConnectionStateChangeListener() 함수에 대한 오버라이딩 @Override public void onChange(int i) { // Toast : 안드로이드가 자체적으로 지원하는 \"토스트 메시지\"로, 웹 프로그래밍에서 JavaScript가 지원하는 alert()와 용도 및 취급이 같다. Toast.makeText(MainActivity.this, \"Connection State = \" + i, Toast.LENGTH_SHORT).show(); } }); checkSdkInfo(); // 참조 : https://developer.android.com/reference/android/view/View#setOnClickListener(android.view.View.OnClickListener) // setOnClickListener 메소드 : \"Register a callback to be invoked when this view is clicked. If this view is not clickable, it becomes clickable.\" // findViewById 메소드 : activity_main.xml에 작성된 요소들과의 Id 매칭을 통해 바인딩한다. mConnectButton = findViewById(R.id.connect_button); mConnectButton.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { if (!mSpenRemote.isConnected()) { // 연결된 상태 connectToSpenRemote(); mConnectButton.setText(\"Disconnect\"); } else { // 연결이 끊어진 상태 disconnectSpenRemote(); mConnectButton.setText(\"Connect\"); mMotionButton.setText(\"Start - Motion\"); } } }); mMotionButton = findViewById(R.id.motion_button); mMotionButton.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { if (!mSpenRemote.isConnected()) { Log.e(TAG, \"not connected!\"); return; } // mIsMotionListening은 boolean으로 정의되었는데, 하드웨어가 연결되어 제대로 동작하고 있는 상황 처리를 위한 변수이다. if (!mIsMotionListening) { SpenUnit airMotionUnit = mSpenUnitManager.getUnit(SpenUnit.TYPE_AIR_MOTION); mSpenUnitManager.registerSpenEventListener(mAirMotionEventListener, airMotionUnit); mMotionButton.setText(\"Stop - Motion\"); } else { SpenUnit airMotionUnit = mSpenUnitManager.getUnit(SpenUnit.TYPE_AIR_MOTION); mSpenUnitManager.unregisterSpenEventListener(airMotionUnit); mMotionButton.setText(\"Start - Motion\"); } mIsMotionListening = !mIsMotionListening; } }); } // 두 번째 메소드 : SDK 정보를 불러옴 // Java에서 디버깅을 위해 로그 출력하기 : Log.d(TAG, \"가나다라\");의 형식을 사용한다. private void checkSdkInfo() { Log.d(TAG, \"VersionCode=\" + mSpenRemote.getVersionCode()); Log.d(TAG, \"versionName=\" + mSpenRemote.getVersionName()); Log.d(TAG, \"Support Button = \" + mSpenRemote.isFeatureEnabled(SpenRemote.FEATURE_TYPE_BUTTON)); Log.d(TAG, \"Support Air motion = \" + mSpenRemote.isFeatureEnabled(SpenRemote.FEATURE_TYPE_AIR_MOTION)); } // 세 번째 메소드 : onResume() @Override protected void onResume() { super.onResume(); } // 네 번째 메소드 : onStop() @Override protected void onStop() { super.onStop(); if (mSpenRemote.isConnected()) { disconnectSpenRemote(); } } // 다섯 번째 메소드 // 여기서 정의된 connectToSpenRemote()는, 첫 번째 메소드에서 사용되었다. private void connectToSpenRemote() { // 이미 연결중인 상황에 대한 예외처리 if (mSpenRemote.isConnected()) { Log.d(TAG, \"Already Connected!\"); Toast.makeText(this, \"Already Connected.\", Toast.LENGTH_SHORT).show(); return; } Log.d(TAG, \"connectToSpenRemote\"); mSpenRemote.setConnectionStateChangeListener(new SpenRemote.ConnectionStateChangeListener() { @Override public void onChange(int state) { // 모종의 이유로 연결이 끊겼을 때 if (state == SpenRemote.State.DISCONNECTED || state == SpenRemote.State.DISCONNECTED_BY_UNKNOWN_REASON) { Toast.makeText(MainActivity.this, \"Disconnected : \" + state, Toast.LENGTH_SHORT).show(); } } }); mSpenRemote.connect(this, mConnectionResultCallback); mIsMotionListening = false; } // 여섯 번째 메소드 // 여기서 정의된 disconnectSpenRemote()는 첫 번째 메소드와 네 번째 메소드에서 이미 사용되었다. private void disconnectSpenRemote() { if (mSpenRemote != null) { mSpenRemote.disconnect(this); } } // 첫 번째 필드 // 참조 : https://developer.samsung.com/galaxy-spen-remote/api-reference/com/samsung/android/sdk/penremote/SpenRemote.ConnectionResultCallback.html // SpenRemote.ConnectionResultCallback 인터페이스 : \"Interface for listening connection result\". private SpenRemote.ConnectionResultCallback mConnectionResultCallback = new SpenRemote.ConnectionResultCallback() { @Override public void onSuccess(SpenUnitManager spenUnitManager) { Log.d(TAG, \"onConnected\"); Toast.makeText(MainActivity.this, \"Connected\", Toast.LENGTH_SHORT).show(); mSpenUnitManager = spenUnitManager; SpenUnit buttonUnit = mSpenUnitManager.getUnit(SpenUnit.TYPE_BUTTON); mSpenUnitManager.registerSpenEventListener(mButtonEventListener, buttonUnit); } @Override public void onFailure(int i) { Log.d(TAG, \"onFailure\"); Toast.makeText(MainActivity.this, \"Disconnected\", Toast.LENGTH_SHORT).show(); } }; private SpenEventListener mButtonEventListener = new SpenEventListener() { @Override public void onEvent(SpenEvent event) { ButtonEvent button = new ButtonEvent(event); if (button.getAction() == ButtonEvent.ACTION_DOWN) { mButtonState.setText(\"BUTTON : Pressed\"); } else if (button.getAction() == ButtonEvent.ACTION_UP) { mButtonState.setText(\"BUTTON : Released\"); } } }; // 두 번째 필드 // 참조 : https://developer.samsung.com/galaxy-spen-remote/api-reference/com/samsung/android/sdk/penremote/SpenEventListener.html // \"Used for receiving SpenEvent from the S Pen Framework when there is new event.\" private SpenEventListener mAirMotionEventListener = new SpenEventListener() { @Override public void onEvent(SpenEvent event) { AirMotionEvent airMotion = new AirMotionEvent(event); float deltaX = airMotion.getDeltaX(); float deltaY = airMotion.getDeltaY(); mAirMotion.setText(\"\" + deltaX + \", \" + deltaY); } };}메모 하나. 오버라이딩이 이루어지는 구조가 특이하다는 인상을 받았다. 가령, 도중에 이런 코드가 있다. mSpenRemote = SpenRemote.getInstance(); mSpenRemote.setConnectionStateChangeListener(new SpenRemote.ConnectionStateChangeListener() { // setConnectionStateChangeListener() 함수에 대한 오버라이딩 @Override public void onChange(int i) { Toast.makeText(MainActivity.this, \"Connection State = \" + i, Toast.LENGTH_SHORT).show(); } }); 함수의 괄호가 닫히기 전에 오버라이딩이 끝난다. 둘. 사전에 유니티 엔진을 얕게 다루어 보았는데, 몇 가지 요소나 구조가 유사하다는 인상도 있었다. 가령, OnCreate()와 OnStart(), OnResume()의 흐름은 유니티에서의 void Start(), void Awake(), void Update()와 동일하다고 느껴진다. 또, activity_main.xml에 작성된 버튼(뷰)을 findViewById()로 찾아내는 것은 유니티에서 오브젝트를 찾을 때 FindGameObjectWithTag()로 찾는 것과 아주 유사하다고 느껴진다. 참고SDK" }, { "title": "아두이노에서 객체지향 사용하기", "url": "/posts/%EC%95%84%EB%91%90%EC%9D%B4%EB%85%B8%EC%97%90%EC%84%9C-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5/", "categories": "프로그래밍/기타, -", "tags": "아두이노, 객체지향, 프로그래밍", "date": "2022-11-04 00:00:00 +0900", "snippet": "예시 코드Arduino_OOP.inovoid setup(){ ...}void loop(){ Money = MainFunctions.AddFiveHundreadWon(Money); Money = MainFunctions.AddOneHundreadWon(Money); Money = MainFunctions.AddFiftyWon(Money);}MainFunctions.cpp#include \"Arduino.h\"class MainFunctions{ public: AddFiveHundreadWon(int Money); AddOneHundreadWon(int Money); AddFiftyWon(int Money);};MainFunctions.h#include \"Arduino.h\"#include \"MainFunctions.h\"int MainFunctions::AddFiftyWon(int Money){ Money += 500; return Money;}int MainFunctions::AddOneHundreadWon(int Money){ Money += 1000; return Money;}int MainFunctions::AddFiveHundreadWon(int Money){ Money += 2000; return Money;}아두이노가 사용하는 언어는 C++C++을 처음 다루어 봤기에 이것이 정확한 정보인지는 모르겠으나, 다른 객체지향 언어와 C++가 가장 큰 차이점을 보이는 점은 C++는 클래스(.cpp) 안에서 변수와 함수를 정의하고, 헤더(.h) 파일에서 변수와 함수에 대한 세부사항을 따로 작성할 수 있다는 것이다." }, { "title": "코루틴", "url": "/posts/%EC%BD%94%EB%A3%A8%ED%8B%B4/", "categories": "프로그래밍/개념공부", "tags": "프로그래밍, 기초", "date": "2022-10-21 00:00:00 +0900", "snippet": "주의! 아직 작성중인 글입니다.코루틴코루틴이란 Cooperatvie RoutineIterator, 이터레이터순서대로 다음 값을 리턴할 수 있는 객체를 말한다.예를 들어, 파이썬의 for문은 자체적으로 이터레이터를 생성하여 동작한다.Generator, 제너레이터이터레이터와 같은 역할을 하는 함수를 제너레이터라고 한다.단, 모든 값을 메모리에 담고 있지 않고, 그때그때 값을 생성해서 반환한다.예를 들어, 0에 대해 계산한 다음 1에 대해 계산하게 되면 이전에 계산하던 0은 잊어버리는 식이다.제너레이터는 데이터를 한 번만 순환한다.yieldyield는 return과 같이 함수가 값을 반환하고 정지하도록 하는 키워드이다.그러나 yield는 generator를 반환하며, 함수를 다시 실행하면 yield가 값을 반환한 지점부터 다시 실행되도록 한다.yield가 포함된 함수는 제너레이터로 분류된다.def function(x): yield xvalue = function(x)print(type(value))# 스포일러# 출력 결과 : &lt;class 'generator'&gt;예시def createGenerator(): for i in range(10): yield i * i # yield는 return과 유사하게 사용된다. 단 제너레이터가 반환될 뿐mygenerator = createGenerator() # 제너레이터 생성for i in mygenerator: print(i)코루틴 사용이유하나의 스레드 위에서 복수개의 실행 흐름을 만들 수 있다. -&gt; 그러나 여전히 멀티스레드는 아님참고" }, { "title": "오늘의 드로잉 #1", "url": "/posts/%EC%98%A4%EB%8A%98%EC%9D%98-%EB%93%9C%EB%A1%9C%EC%9E%89/", "categories": "그림", "tags": "드로잉", "date": "2022-08-25 00:00:00 +0900", "snippet": "" }, { "title": "유니티로 구현된 대공자주포", "url": "/posts/LAV/", "categories": "프로그래밍", "tags": "Unity", "date": "2022-08-24 00:00:00 +0900", "snippet": "삘이 들어 만들어 본 대공자주포" }, { "title": "CPU의 구조와 동작원리", "url": "/posts/CPU%EC%9D%98-%EC%9D%B4%ED%95%B4/", "categories": "전자기계", "tags": "Arm, AP, SoC, 스마트폰, 스마트폰 프로세서", "date": "2022-08-16 00:00:00 +0900", "snippet": "주의! 아직 작성중인 글입니다.컴퓨터의 역사컴퓨터(computer)는 ‘계산하다’라는 뜻을 가진 영어 동사 compute에 어미 -er가 붙어 합성된 단어로, compute는 라틴어 콤퓨타레(computare)에서 뿌리를 두고 있으며, 이 단어는 함께(com) 생각하다(putus)의 합성어이다.컴퓨터는 아직 최초로 만들어진 컴퓨터보다 더 오래 산 인간이 아직 살아있을 정도로 역사가 짧은 물건이다.그 시초는 2차 세계대전 독일의 암호 발생기 에니그마를 해독하기 위해 영국의 앨런 튜링이 고안한 암호 해독기, ‘튜링 머신’에 있는데, 컴퓨터가 어떤 물건인지 잘 보여준다. (computare : com(함께) + putus(생각하다))즉, 컴퓨터는 인간은 할 수 없는 빠르고 효율적인 계산을 수행하거나 인간의 업무를 보조하기 위한 물건으로, 이것의 역사는 2차 세계대전에서 발생했지만 역할을 따져보았을 때 어느 정도는 필연적인 물건이다.CPU트랜지스터와 반도체CPU의 구조를 이해하기 전에, 용어를 사전에 한 번 짚고 갈 필요가 있다.《가장 기본적인 형태의 트랜지스터》트랜지스터는 대표적인 반도체 소자로, 컴퓨터에서 스위칭 작용을 한다. (가변 저항, 증폭 작용(Amplifier))CPU는 트랜지스터의 광범위한 조합물이다.“트랜지스터(Transistor)”는 전기전도성을 가지면서 저항의 역할도 수행한다는 의미를 담아 Transfer(전송하다)와 Varistor(저항 소자)의 두 영단어를 합성하여 지은 이름이다.트랜지스터는 전류 증폭, 전류 스위칭(On/Off), 등의 역할을 맡는데, 회로의 배치에 따라 AND(논리곱), OR(논리합), XOR(배타적 논리합) 게이트(gate) 등의 논리게이트를 구성하여 산술(Arithmetic)과 논리(logic)에 대한 연산을 수행한다.산술 연산 예시논리 연산 예시산술 논리 장치(ALU)논리연산은 회로에 걸리는 규격화된 전압값에 따라 0과 1로 치환되어 계산된다. 대개 전압값이 낮으면 0, 전압값이 높으면 1로 치환된다.논리게이트를 끼리끼리 조합하면 그 경우와 규모에 따라 산수 연산과 보다 복잡한 논리연산이 가능하게 되며, 이 트랜지스터 조합 블록을 산술 논리 장치(ALU) 라고 부른다.CPU에서 연산은 ALU에서 이루어진다. 이에 ALU의 입출력을 조율하는 CU(제어 장치), 연산 도중의 임시 저장소 역할을 하는 레지스터(Register) 등이 CPU를 구성하며, 데이터 통신 체계인 버스(Bus), 병목현상(데이터 입출력 지연)을 방지하기 위한 캐시(Cache) 등 다른 CPU 구성 요소도 있지만, 출력물이 만들어지는 장소는 ALU이며 이 산술논리장치는 트랜지스터라는 지식적 산물이 근간을 이룬다.폰 노이만 구조아키텍처CPU를 구성할 때 개별적인 ALU를 묶어 보다 효율적으로 동작하는 하나의 블록을 구성할 수 있는데, 이 때 하나의 CPU의 구성 요소가 되는 개별 블록를 코어(Core)라고 부른다.또한 CPU 구성 요소 중 하나인 캐시는 데이터 전송 속도와 데이터 전송 속도에 반비례하는 그 용량에 따라 L1, L2, L3 캐시로 분류된다.CPU는 폰 노이만 구조라는 큰 틀 안에서 각 회사의 방침에 따라 세부구조가 각기 다르게 설계된다. 코어의 구조나 개수가 다를 수 있고, 코어의 주위에 L1, L2, L3 캐시를 레벨마다 다른 방법으로 배치할 수도 있다.이렇게 설계되는 CPU의 설계구조를 Architecture, 아키텍처라고 한다. 아키텍처는 회사마다 다르고, 한 회사의 아키텍처도 시간이 흐르고 구조가 수정됨에 따라 변할 수 있다.반도체설명에 앞서, 반도체가 무엇이냐는 물음에는 이렇게 답하는 것이 좋을 것이다. 반도체란, 원자가띠에 있는 최외각전자가 전도띠에 전이하여 자유전자가 되기 위해 필요한 띠 틈만큼의 에너지가 전도체와 부도체 사이 수준인 물질로, 실리콘(Si)과 저마늄(Ge) 등이 해당된다.이것은 맞는 설명이고 일반적인 지식이다.그러나, 반도체라는 단어에는 가공되어 소비되는 반도체 칩, 혹은 반도체 산업 그 자체를 지칭하기 위한 관습적인 의미가 있으며 나는 이것을 사용할 것이다.오늘날 반도체 산업이 국가보안과 향후 미래안정에 관여할 정도로 중요한 산업으로 뛰어오른 것은 이것이 컴퓨터를 생산하는 기술임에 있다.더 작은 면적으로 더 적은 에너지 자원을 소비하는 좋은 반도체를 생산하기 위해선 좋은 반도체 기술이 필요하다.보너스 : 모바일 SoC반도체는 크게 램(RAM)과 롬(ROM)과 같이 정보를 저장하기 위한 메모리반도체와, CPU 또는 GPU와 같이 정보를 처리하기 위한 시스템반도체의 두 가지 유형으로 분류된다.SoC(System on Chip)는 대표적인 시스템반도체의 일종으로, CPU, GPU, 특히 모바일 프로세서의 경우 여기에 이미지 데이터 처리를 위한 ISP(Image Signal Processor), NPU(Neural Processing Unit) 외 VPU, DSP, 모뎀(MODEM)…등, 전체의 시스템(System)이 칩(Chip) 하나에 담겨있는 기술집약 반도체를 말한다.이 용어는 AP(Application Processor)와도 혼동되는데, SoC가 개념을 객관화하고 분류하기 위한 집합에 붙여진 이름이라면 AP는 그 집합의 구성원소로 이해할 수 있다. 다음과 같이 표현하면 적절할 것이다.2021년의 대표적인 모바일 SoC인 스냅드래곤 888과 엑시노스 2100의 공식 다이어그램.기기사용에 필요한 모든 것들을 하나의 칩에서 조율한다.팹리스 기업, Arm반도체를 설계하되 직접 생산하지 않는 기업을 제조(fabrication)하지 않는(less)다는 의미로 팹리스(fabless) 기업이라고 부른다.Arm은 영국의 대표적인 팹리스 기업으로, 설계한 프로세서를 하드 마크로셀(Hard Macrocell, 코어 크기와 전압 등이 고정되어 설계변경이 불가능) 또는 합성 가능한 코어(Synthesizable core, 코어 크기와 내부 메모리 변경이 가능)를 지적재산권(IP)의 형태로 반도체 제조 회사에 라이센싱하여 판매한다.Arm으로부터 코어 설계도를 전달받은 SoC를 제조하는 회사는 Arm Core에 주변장치를 추가하여 SoC를 구성한 후 판매하거나 자체 제품에서 사용한다.참고https://en.wikipedia.org/wiki/Central_processing_unit" }, { "title": "깃허브 블로그에 Chirpy 테마 적용하기", "url": "/posts/%EC%B2%AB-%ED%8F%AC%EC%8A%A4%ED%8C%85/", "categories": "블로그", "tags": "깃허브, 블로그, Github, blog", "date": "2022-08-13 00:00:00 +0900", "snippet": "이틀간의 고군분투 끝에 깃허브 블로그를 개설했다.깃허브에서 Repository를 만들고, 클론하여 내 컴퓨터에 불러오고, 다시 푸쉬를 하는 과정 등까지는 잘 따라갈 수 있었으나더 나아가 템플릿, 그것도 마음에 쏙 드는 템플릿을 적용하는 것이 난관이었다.템플릿의 이름은 Chirpy인데, 사실 다른 템플릿 대체제는 많았지만 심미성과 추가기능 지원의 관점에서 지금의 템플릿을 포기하고 싶지 않아 오기 삼아서 적용해보기로 했다.구글링으로 정보를 찾아봐도 국내 정보로는 해결이 힘들었으므로, 이 템플릿을 적용하는 데에 도움이 된 여러 글과 방법을 정리하여 작성해 둔다.Chirpy 템플릿은 이곳에서 다운받을 수 있다.1. layout: home # index page 오류가장 먼저, 그리고 많이 만나는 오류다.Git Bash으로 템플릿이 적용된 블로그 파일이 위치한 경로로 이동한 뒤,bash tools/init.sh위의 명령어를 입력하면 몇 가지 초기화 작업이 수행되고 _Initialization successful!_이 출력되며 해결된다.2. gh-pages 브랜치의 누락Chirpy 템플릿을 적용한 사람들이 함께 강조한 것 중 하나는 브랜치(Branch) 세팅을 gh-pages로 설정하라는 것이었으나, 실제로 확인 가능한 브랜치 옵션에는 main밖에 없었다.이런 경우, gh-pages 브랜치를 직접 설치해 주어야 한다.git branch gh-pages git push origin gh-pages커맨드 창에 두 명령어를 입력하면 해결된다.3. pages-deploy.yml 파일 수정.github/workflows 경로에 있는 pages-deploy.yml 파일의 내역을 일부 수정해야 한다.runs-on: windows-latestruby-version: 3.1.2(ruby -v를 통해 확인)우분투(ubuntu-latest)로 기본 설정되어 있으나 윈도우 환경에서 작업하는 경우 이를 windows로 바꿔주어야 하며,루비 버전은 커맨드 창에서의 ruby -v 명령어를 통해 확인할 수 있는 내역으로 수정해야 한다.pages-deploy.yml 파일의 내용이 알맞게 수정되면 해결된다.4. 빌드 단계에서의 오류나의 경우에는, 템플릿이 푸쉬 후 빌드되는 도중 빌드가 실패되었다며 위의 문구를 여러 차례 만날 수 있었다.파일을 수정하고, 그냥 다시 푸쉬도 해보고, 처음부터도 다시 차근차근 따라해 보면서 10번은 넘게 이 오류를 본 것 같다.해결방안은 다름아닌 Chirpy 깃허브 페이지/issues 창에서 글을 뒤지다보니 찾을 수 있었는데,tools 파일에 위치한 deploy.sh 쉘 스크립트의 내용을 수정해줘야 한다는 것이다.main() { init build test &lt;-- 이 항목을 삭제해 주어야 한다 resume_site_dir if $_opt_dry_run; then exit 0 fi setup_gh backup flush deploy}스크립트에 작성된 코드 중에 있는 main()함수의 항목 중 “test”를 지우면 해결된다." } ]
